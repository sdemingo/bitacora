#!/usr/bin/env python3

import sys
import os
import grp
import random
import re
import shutil
from string import Template
from bs4 import BeautifulSoup
from datetime import datetime
from pathlib import Path
import markdown
import filecmp

## Ruta de instalación de zine
INSTALL_PATH="."

## Lugar de publicación de los ficheros html
HTML_ROOT_DIR="./htmltest" 

## Lugar del SF donde están los artículos aceptados y listos para publicar
ZINE_REPO="./mdtest"
ACCEPTED_DIR=ZINE_REPO+"/users"    
STATIC_FILES=ZINE_REPO+"/static"

USR_ROOT="./usrtest"      # markdown dratf files (must be /home)

HTML_TEMPLATES=INSTALL_PATH+"/templates"
CSS_FILE=INSTALL_PATH+"/resources/estilo.css"
FONTS=INSTALL_PATH+"/resources/fonts"


MESSAGE_NEW_POST="\n\t ========= ARTÍCULO NUEVO ========= \n\n"
MESSAGE_UPDATE_POST="\n\t ========= ARTÍCULO PARA ACTUALIZAR  ========= \n\n"
ZINE_USERS_LOG_FILE="registro.txt"
ZINE_MODERATE_LOG_FILE="moderate-log.txt"
ZINE_ADMIN_GROUP_NAME="zineadm"

DEBUG_MODE=True

#
# En este array guardamos todos los articulos procesados en forma
# de tuplas. Cada tupla está formada por (ruta del artículo, usuario, fecha)
#
posts=[]


def debug(error):
    if DEBUG_MODE and error!=None: print(error)

#
# Crea una página de índice con los úĺtimos artículos de todos
# los usuarios. Esta sería la portada general del blog
#
def createMainBlogIndex(limit=10):
    indexContent=""
    i=0
    posts.sort(key=lambda t:t[2],reverse=True)
    for post in posts:
        path=post[0]
        author=post[1]
        filecontent=Path(HTML_ROOT_DIR+"/users/"+path).read_text()
        url=path
        title,summary = getTitleAndSummaryFromArticle(filecontent)
        sdate=getDateFromString(os.path.basename(path).strip(".html"))
        pdate=sdate.strftime("%d/%m/%Y")
        with open(HTML_TEMPLATES+"/main-index-entry.html") as t:
                template=Template(t.read())
                newitem=template.substitute(title=title,url=url,
                author=author,date=pdate,summary=summary)
        indexContent=indexContent+newitem
        i+=1
        if (i==limit):
            break

    print ("Creating general /index.html")
    with open(HTML_TEMPLATES+"/main-index.html") as t:
        template=Template(t.read())
        html=template.substitute(index=indexContent)
        with open(HTML_ROOT_DIR+"/index.html","w") as f:
            f.write(html)
            f.close()



def createFullBlogIndex():
    indexContent=""
    i=0
    posts.sort(key=lambda t:t[2],reverse=True)
    for post in posts:
        path=post[0]
        author=post[1]
        filecontent=Path(HTML_ROOT_DIR+"/users/"+path).read_text()
        url=path
        title,summary = getTitleAndSummaryFromArticle(filecontent)
        sdate=getDateFromString(os.path.basename(path).strip(".html"))
        pdate=sdate.strftime("%d/%m/%Y")
        with open(HTML_TEMPLATES+"/main-index-all-entry.html") as t:
                template=Template(t.read())
                newitem=template.substitute(title=title,url=url,
                user=author,date=pdate,summary=summary)
        indexContent=indexContent+newitem

    print ("Creating general /index.html")
    with open(HTML_TEMPLATES+"/main-index-all.html") as t:
        template=Template(t.read())
        html=template.substitute(index=indexContent)
        with open(HTML_ROOT_DIR+"/index-all.html","w") as f:
            f.write(html)
            f.close()


#
# Extra el título y el resumen (primer párrafo) de un contenido
# html usando el scrapper 
#
def getTitleAndSummaryFromArticle(filecontent):
    soup = BeautifulSoup(filecontent, "html.parser")
    title=soup.select("#article-content h1")
    if len(title)>0:
        title=title[0].text
    else:
        title=""
    summary=soup.find("p").text
    return title,summary



#
# Crea una página de index que enlaza los ficheros contenidos
# en ese directorio añadiendo el resumen a cada artículo
#
def createMainIndexFrom(user,limit=5):
    indexContent=""
    i=0
    files=os.listdir(HTML_ROOT_DIR+"/users/"+user)
    #files.sort(reverse=True)
    files.sort()
    for filename in os.listdir(HTML_ROOT_DIR+"/users/"+user):
        if filename=="index.html":
            continue
        filecontent=Path(HTML_ROOT_DIR+"/users/"+user+"/"+filename).read_text()
        url=filename
        title,summary = getTitleAndSummaryFromArticle(filecontent)
        sdate=getDateFromString(filename.strip(".html"))
        pdate=sdate.strftime("%d/%m/%Y")
        with open(HTML_TEMPLATES+"/user-index-last-entry.html") as t:
                template=Template(t.read())
                newitem=template.substitute(title=title,url=url,
                author=user,date=pdate,summary=summary)
        indexContent=newitem+indexContent
        i+=1
        if (i==limit):
            break

    print ("Creating "+user+"/index.html")
    with open(HTML_TEMPLATES+"/user-index-last.html") as t:
        template=Template(t.read())
        html=template.substitute(user=user,index=indexContent)
        with open(HTML_ROOT_DIR+"/users/"+user+"/index.html","w") as f:
            f.write(html)
            f.close()


#
# Crea la página con el indice total de todos los artículos
# creados por un usuario. Esta vez sin resumen. Solo mostrando
# la fecha de cada uno de ellos
#
def createFullIndexFrom(user):
    indexContent=""
    files=os.listdir(HTML_ROOT_DIR+"/users/"+user)
    files.sort(reverse=True)
    for filename in files:
        if (filename=="index.html") or (filename=="index-all.html"):
            continue

        filecontent=Path(HTML_ROOT_DIR+"/users/"+user+"/"+filename).read_text()
        url=filename
        title,summary = getTitleAndSummaryFromArticle(filecontent)
        sdate=getDateFromString(filename.strip(".html"))
        pdate=sdate.strftime("%d/%m/%Y")
        with open(HTML_TEMPLATES+"/user-index-all-entry.html") as t:
                template=Template(t.read())
                newitem=template.substitute(title=title,url=url,date=pdate)
        indexContent+=newitem

        # Añado el artículo al array general
        posts.append((user+"/"+filename,user,sdate))

    print ("Creating "+user+"/index-all.html")
    with open(HTML_TEMPLATES+"/user-index-all.html") as t:
        template=Template(t.read())
        html=template.substitute(user=user,index=indexContent)
        with open(HTML_ROOT_DIR+"/users/"+user+"/index-all.html","w") as f:
            f.write(html)
            f.close()    


#
# Extrae el título de un documento markdown. 
# Se queda con el texto del primer encabezado
#
def extractTitleFromMD(mdcontent):
    regex = r"^# (.+)"
    test_str=mdcontent
    matches = re.search(regex, test_str, re.MULTILINE)
    return matches.groups()[0]




# 
# Esta función publica el contenido aceptado de un usuario convirtiéndolos en
# HTML y colocándolos en el directorio correspondiente i indicado en
# HTML_ROOT_DIR
#
def publishUserContent(user,template):
    print ("Generating HTML content from "+user)
    for filename in os.listdir(ACCEPTED_DIR+"/"+user):
        with open(ACCEPTED_DIR+"/"+user+"/"+filename) as f:
            md=f.read()
            title=extractTitleFromMD(md)
            htmlpost = markdown.markdown(md,extensions=['tables','fenced_code'])
            sdate=getDateFromString(filename.strip(".md"))
            pdate=sdate.strftime("%Y%m%d")
            title,summary = getTitleAndSummaryFromArticle(htmlpost)
            html=template.substitute(content=htmlpost,user=user,date=sdate.strftime("%d/%m/%Y"))
            with open(HTML_ROOT_DIR+"/users/"+user+"/"+pdate+".html","w") as h:
                h.write(html)
                h.close()
                f.close()



# 
# Esta función publica el contenido estático de resources/static
#
def publishStaticContent():
    print ("Generating static content")
    template=""
    try:
        with open(HTML_TEMPLATES+"/static-post.html") as t:
            template=Template(t.read())
            if template=="":
                return

        for filename in os.listdir(STATIC_FILES):
            with open(STATIC_FILES+"/"+filename) as f:
                md=f.read()
                title=extractTitleFromMD(md)
                htmlpost = markdown.markdown(md)
                htmlname=filename.strip(".md")
                html=template.substitute(content=htmlpost)
                with open(HTML_ROOT_DIR+"/static/"+htmlname+".html","w") as h:
                    h.write(html)
                    h.close()
                    f.close()
    except FileNotFoundError as ferr:
        print ("ERROR: No se encontro fichero: "+str(ferr))




#
# Esta función publica el contenido de todos los usuarios
# y crea todos los índices de los usuarios
#
def publishAllContent():
    contentTemplate=""
    with open(HTML_TEMPLATES+"/user-full-post.html") as t:
        contentTemplate=Template(t.read())
        if contentTemplate=="":
            return
    
    os.system("rm -r "+HTML_ROOT_DIR)
    os.system("mkdir -p "+HTML_ROOT_DIR)
    os.system("mkdir -p "+HTML_ROOT_DIR+"/resources")
    os.system("mkdir -p "+HTML_ROOT_DIR+"/static")
    os.system("mkdir -p "+HTML_ROOT_DIR+"/users")
    for user in os.listdir(ACCEPTED_DIR):
        os.system("mkdir -p "+HTML_ROOT_DIR+"/users/"+user)
        publishUserContent(user,contentTemplate)
        createMainIndexFrom(user)
        createFullIndexFrom(user)

    os.system("cp "+CSS_FILE+" "+HTML_ROOT_DIR+"/resources")
    os.system("cp -r "+FONTS+" "+HTML_ROOT_DIR+"/resources")
    publishStaticContent()
    createMainBlogIndex()
    createFullBlogIndex()


#
# Acepta el artículo moviéndolo desde el espacio personal del usuario
# al repositorio de artículos aceptados
#
def acceptPost(srcpath,user):
    try:
        os.makedirs(ACCEPTED_DIR+"/"+user)
    except FileExistsError:
        pass

    filename=os.path.basename(srcpath)
    dstpath=ACCEPTED_DIR+"/"+user+"/"+filename
    shutil.copyfile(srcpath, dstpath)
    msg="["+srcpath+"]  ACEPTADO"
    log(USR_ROOT+"/"+user+"/blog/"+ZINE_USERS_LOG_FILE,msg) 
    log(ZINE_MODERATE_LOG_FILE,msg)



def rejectPost(srcpath,user,comment=""):
    msg="["+srcpath+"]  RECHAZADO  "+comment
    log(USR_ROOT+"/"+user+"/blog/"+ZINE_USERS_LOG_FILE, msg) 
    log(ZINE_MODERATE_LOG_FILE,msg)


def log(logfile, message):
    changeGrp=False
    try:
        logpath = Path(logfile)
        if not logfile.exists():
            changeGrp=True
        with open(logfile,"a+") as f:
            f.write(message+"\n")
            f.close()
        if changeGrp:
            os.system("chgrp "+ZINE_ADMIN_GROUP_NAME+" "+logfile)
    except Exception as e:
        print ("ERRROR: Fallo escritura en log: "+logfile)



#
# Retorna un objeto fecha a partir de un string
# con la forma DDMMYYYY
#
def getDateFromString(datestr):
    return datetime.strptime(datestr,"%Y%m%d")



#
# Traspasa ficheros desde los directorios personales de los usuarios
# al repositorio general de ficheros aceptados en ACCEPTED_DIR
#
def moderateContent():
    moderateFiles=[]  #(archivo, user, flag_nuevo)
    for user in os.listdir(USR_ROOT):
        for file in os.listdir(USR_ROOT+"/"+user+"/blog"):
            if ((file == ZINE_USERS_LOG_FILE) or (file.index(".md") < 0 )):
                continue
            srcfile=USR_ROOT+"/"+user+"/blog"+"/"+file
            acceptedfile=ACCEPTED_DIR+"/"+user+"/"+file
            if (not os.access(srcfile, os.W_OK)):
                rejectPost(srcfile, user, "Revisa los permisos de acceso de tu artículo. Vuelve a leer el manual de ayuda de Zine")
                continue
            if not os.path.exists(acceptedfile):
                moderateFiles.append((srcfile, acceptedfile, user,True))      # articulo nuevo
            else: 
                if not filecmp.cmp(srcfile,acceptedfile):
                    moderateFiles.append((srcfile, acceptedfile, user, False)) # articulo para actualizar

            
    print("Hay "+str(len(moderateFiles))+" pendientes de moderación")

    try:
        input("Pulsa 'enter' para iniciar la revisión o Ctrl+C para abandonar\n")
    except Exception as err:
        debug(err)
        return

    for srcpath,acceptpath,user,newpost in moderateFiles:
        nextpost=False
        while not nextpost:
            os.system("clear")
            if newpost:
                msg=MESSAGE_NEW_POST+"\tFichero "+srcpath+"\n\tUsuario: "+user+"\n\n"
                os.system('echo -n "'+msg+'""$(cat '+srcpath+')" | less -c')
            else:
                msg=MESSAGE_UPDATE_POST+"\tFichero "+srcpath+"\n\tUsuario: "+user+"\n\n"
                os.system('echo -n "'+msg+'""$(diff -c '+acceptpath+' '+srcpath+')" | less -c')
            try:
                print("¿Aceptas el artículo "+srcpath+"? Pulsa")
                opt=input(" [S]i\t[N]o\t[I]gnorar\t[V]er de nuevo\t\tCtrl+C para abandonar: ")
                if opt=="S" or opt=="s":
                    acceptPost(srcpath,user)
                    nextpost=True
                if opt=="N" or opt=="n":
                    rejectPost(srcpath,user,"Contenido inapropiado. Las razones se han incluido en el fichero")
                    os.system("nano "+srcpath)
                    nextpost=True
                if opt=="I" or opt=="i":
                    nextpost=True

            except Exception as err:
                #debug(err)
                return



if __name__=='__main__':

    try:
        grp.getgrnam(ZINE_ADMIN_GROUP_NAME)
    except KeyError:
        print("El grupo "+ZINE_ADMIN_GROUP_NAME+" no existe y debería estar presente. Consulte este problema con el administrador")
        sys.exit(0)

    if (len(sys.argv)<2) or (sys.argv[1]!="--build") or (sys.argv[1]!="--moderate"):
        print ("\t\t zineadmin [ --build | --moderate ] ")
        sys.exit(0)

    if sys.argv[1]=="--build":
        publishAllContent()


    if sys.argv[1]=="--moderate":
        moderateContent()
